"""
Django settings for LibraryProject project - ENHANCED HTTPS SECURITY CONFIGURATION

Generated by 'django-admin startproject' using Django 5.2.4.

This settings file implements comprehensive HTTPS security measures following Django security best practices
including HTTPS enforcement, secure headers, and HSTS configuration.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

import os
from pathlib import Path
from django.contrib.messages import constants as messages

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Keep the secret key used in production secret!
# In production, this should be loaded from environment variables
SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY', 'django-insecure-vei!lhn%e2$e0*ybq3pap$42*0y6pcu%c@*$5wbz#+v_$y#hg&')

# DEBUG is set to False in production to prevent information disclosure
DEBUG = os.environ.get('DJANGO_DEBUG', 'True').lower() in ('true', '1', 'yes')

# Allowed hosts to prevent Host header attacks
# In production, replace with actual domain names
ALLOWED_HOSTS = os.environ.get('DJANGO_ALLOWED_HOSTS', 'localhost,127.0.0.1').split(',')

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'bookshelf',
    'relationship_app',
    # Content Security Policy middleware
    'csp',  # While using django-csp package
]

# SECURE MIDDLEWARE CONFIGURATION
# Security middleware should be at the top for maximum protection
MIDDLEWARE = [
    # STEP 1: Security middleware must be first to enforce HTTPS redirects
    'django.middleware.security.SecurityMiddleware',
    
    # Content Security Policy middleware 
    'csp.middleware.CSPMiddleware',
    
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    
    # CSRF protection middleware - prevents CSRF attacks
    'django.middleware.csrf.CsrfViewMiddleware',
    
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    
    # Clickjacking protection - prevents clickjacking attacks
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'LibraryProject.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'LibraryProject.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation - Enhanced security for user passwords
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 12,  # Increased minimum password length
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'  # For production static file serving

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Custom User Model Configuration
AUTH_USER_MODEL = 'bookshelf.CustomUser'

# Authentication settings
LOGIN_URL = '/login/'
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/'

# Message framework settings
MESSAGE_TAGS = {
    messages.DEBUG: 'debug',
    messages.INFO: 'info',
    messages.SUCCESS: 'success',
    messages.WARNING: 'warning',
    messages.ERROR: 'error',
}


# ENHANCED HTTPS SECURITY SETTINGS - STEPS 1, 2, AND 3 IMPLEMENTATION

# STEP 1: Configure Django for HTTPS Support

# HTTPS redirect enforcement
# Forces all HTTP requests to be redirected to HTTPS automatically, ensuring all communication between client and server is encrypted
SECURE_SSL_REDIRECT = not DEBUG  # True in production, False in development

# HTTP Strict Transport Security (HSTS) configuration
# HSTS tells browsers to only access the site via HTTPS for the specified duration, prevents protocol downgrade attacks and cookie hijacking
SECURE_HSTS_SECONDS = 31536000 if not DEBUG else 0  # 1 year (365 days * 24 hours * 60 minutes * 60 seconds)

# Include all subdomains in HSTS policy
# This extends HSTS protection to all subdomains of the site, prevents attackers from accessing subdomains via HTTP
SECURE_HSTS_INCLUDE_SUBDOMAINS = not DEBUG  # True in production

# Enable HSTS preloading
# Allows the site to be included in browsers' preloaded HSTS lists
# Provides HSTS protection even on first visit to the site
SECURE_HSTS_PRELOAD = not DEBUG  # True in production

# Force HTTPS for proxy headers
# Ensures Django recognizes HTTPS connections when behind a reverse proxy (nginx, Apache)
# Important for proper HTTPS detection in production environments
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https') if not DEBUG else None

# STEP 2: Enforce Secure Cookies

# HTTPS-only session cookies
# Ensures session cookies are only transmitted over encrypted HTTPS connections, prevents session hijacking through unencrypted HTTP connections
SESSION_COOKIE_SECURE = not DEBUG  # True in production, False in development for testing

# HTTPS-only CSRF cookies
# Ensures CSRF protection cookies are only sent over HTTPS, prevents CSRF token interception over insecure connections
CSRF_COOKIE_SECURE = not DEBUG  # True in production, False in development for testing

# Additional secure cookie settings, prevents JavaScript access to session and CSRF cookies (XSS protection)
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = True

# Session timeout configuration, Limits session duration to reduce risk of session hijacking
SESSION_COOKIE_AGE = 3600  # 1 hour session timeout

# Secure cookie naming and path restrictions
SESSION_COOKIE_NAME = 'sessionid_secure'  # Use descriptive, secure cookie names
CSRF_COOKIE_NAME = 'csrftoken_secure'     # Avoid default predictable names

# Cookie SameSite attribute for CSRF protection, provides additional protection against cross-site request forgery
CSRF_COOKIE_SAMESITE = 'Strict'  # 'Strict', 'Lax', or None
SESSION_COOKIE_SAMESITE = 'Lax'   # 'Lax' for better UX with authentication flows

# STEP 3: Implement Secure Headers

# Clickjacking protection via X-Frame-Options header
# Prevents site from being embedded in frames on other sites
# 'DENY': Never allow framing (most secure)
# 'SAMEORIGIN': Allow framing only from same origin
X_FRAME_OPTIONS = 'DENY'

# MIME-type sniffing protection, prevents browsers from interpreting files as different MIME type than declared
# Helps prevent XSS attacks through file upload vulnerabilities
SECURE_CONTENT_TYPE_NOSNIFF = True

# Browser XSS filtering
# Enables browser's built-in XSS filtering mechanism
# Provides additional layer of protection against reflected XSS attacks
SECURE_BROWSER_XSS_FILTER = True

# Referrer policy configuration
# Controls how much referrer information is sent with requests
# 'strict-origin-when-cross-origin': Send full URL for same-origin, origin only for cross-origin HTTPS
SECURE_REFERRER_POLICY = 'strict-origin-when-cross-origin'

# Cross-Origin-Opener-Policy header
# Prevents other sites from gaining reference to your window object
# Helps protect against cross-origin attacks
SECURE_CROSS_ORIGIN_OPENER_POLICY = 'same-origin'

# CONTENT SECURITY POLICY (CSP) - ADDITIONAL SECURITY LAYER

# Content Security Policy configuration
# CSP helps prevent XSS attacks by controlling which resources can be loaded
# Define strict policies for different resource types
CONTENT_SECURITY_POLICY = {
    'DIRECTIVES': {
        # Control base URI for relative URLs
        'base-uri': ("'self'",),
        
        # Control allowed connection endpoints (AJAX, WebSocket, etc.)
        'connect-src': ("'self'",),
        
        # Default fallback for resource loading
        'default-src': ("'self'",),
        
        # Control font loading sources
        'font-src': ("'self'", 'https://fonts.gstatic.com'),
        
        # Control form submission targets
        'form-action': ("'self'",),
        
        # Prevent framing (additional protection beyond X-Frame-Options)
        'frame-ancestors': ("'none'",),
        
        # Control image loading sources
        'img-src': ("'self'", 'data:', 'https:'),
        
        # Control JavaScript sources (be careful with 'unsafe-inline')
        'script-src': ("'self'", "'unsafe-inline'"),  # Consider removing unsafe-inline in production
        
        # Control CSS sources
        'style-src': ("'self'", "'unsafe-inline'", 'https://cdn.jsdelivr.net'),
        
        # Control object/embed sources
        'object-src': ("'none'",),
        
        # Control where documents can be nested (frames, objects, etc.)
        'child-src': ("'self'",),
        
        # Control web worker sources
        'worker-src': ("'self'",),
        
        # Control manifest file sources
        'manifest-src': ("'self'",),
        
        # Control media sources (audio, video)
        'media-src': ("'self'",),
    }
}

# ENVIRONMENT-SPECIFIC SECURITY CONFIGURATIONS

# Production vs Development environment detection
PRODUCTION_ENVIRONMENT = not DEBUG

# Environment-specific SSL settings
if PRODUCTION_ENVIRONMENT:
    # Production-only security enhancements
    
    # Force secure connections for admin interface
    SECURE_SSL_REDIRECT = True
    
    # Require HTTPS for authentication and session management
    LOGIN_URL = '/login/'  # Update with actual domain name
    
    # Additional production security headers
    SECURE_HSTS_SECONDS = 63072000  # 2 years in production for better security
    
    # Enable all secure cookie settings
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    
    # Stricter CSP in production
    CONTENT_SECURITY_POLICY['DIRECTIVES']['script-src'] = ("'self'",)  # Remove unsafe-inline
    
else:
    # Development environment settings
    # Allow HTTP for local development while maintaining security awareness
    
    # Log security warnings in development
    import logging
    security_logger = logging.getLogger('django.security')
    security_logger.warning('Running in development mode - HTTPS security features disabled')

# ENHANCED LOGGING CONFIGURATION FOR SECURITY MONITORING

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'security': {
            'format': 'SECURITY {levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'security_file': {
            'level': 'WARNING',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs' / 'security.log',
            'maxBytes': 1024*1024*15,  # 15MB
            'backupCount': 10,
            'formatter': 'security',
        },
        'https_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs' / 'https_security.log',
            'maxBytes': 1024*1024*10,  # 10MB
            'backupCount': 5,
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django.security': {
            'handlers': ['security_file', 'console'],
            'level': 'WARNING',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['security_file', 'https_file', 'console'],
            'level': 'ERROR',
            'propagate': True,
        },
        'django.security.csrf': {
            'handlers': ['security_file'],
            'level': 'WARNING',
            'propagate': True,
        },
    },
}

# Create logs directory if it doesn't exist
os.makedirs(BASE_DIR / 'logs', exist_ok=True)

# PRODUCTION DEPLOYMENT CHECKLIST AND SECURITY VALIDATION

"""
CRITICAL PRODUCTION HTTPS SECURITY CHECKLIST:

✅ STEP 1: HTTPS Configuration
   - SECURE_SSL_REDIRECT = True (Forces HTTPS redirects)
   - SECURE_HSTS_SECONDS = 31536000+ (1+ year HSTS)
   - SECURE_HSTS_INCLUDE_SUBDOMAINS = True
   - SECURE_HSTS_PRELOAD = True

✅ STEP 2: Secure Cookies
   - SESSION_COOKIE_SECURE = True (HTTPS-only sessions)
   - CSRF_COOKIE_SECURE = True (HTTPS-only CSRF tokens)
   - Additional HttpOnly protections enabled

✅ STEP 3: Security Headers
   - X_FRAME_OPTIONS = 'DENY' (Clickjacking protection)
   - SECURE_CONTENT_TYPE_NOSNIFF = True (MIME-sniffing protection)
   - SECURE_BROWSER_XSS_FILTER = True (XSS protection)

ADDITIONAL PRODUCTION REQUIREMENTS:
1. SSL/TLS Certificate Installation:
   - Install valid SSL certificate from trusted CA
   - Configure web server (Nginx/Apache) for HTTPS
   - Test certificate chain and validity

2. Web Server Configuration:
   - Configure HTTP to HTTPS redirects at server level
   - Set up proper SSL/TLS protocols (TLS 1.2+)
   - Configure secure cipher suites
   - Enable OCSP stapling

3. Environment Variables:
   - Set DJANGO_DEBUG=False
   - Use secure SECRET_KEY from environment
   - Configure proper DJANGO_ALLOWED_HOSTS

4. Security Testing:
   - Run SSL Labs SSL Test (https://www.ssllabs.com/ssltest/)
   - Use Django security check: python manage.py check --deploy
   - Test HTTPS enforcement and redirects
   - Verify HSTS headers are sent
   - Test secure cookie transmission

5. Monitoring and Maintenance:
   - Monitor SSL certificate expiration
   - Regular security updates
   - Log monitoring for security events
   - Regular penetration testing
"""